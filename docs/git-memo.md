---
layout: page
title: "git memo"
permalink: /docs/git-memo
---

# ソフトウェアとは
## ソフトウェアの定義
- 実行されることによって必要な特性，機能，性能を提供する命令語群（コンピュータプログラム）
- プログラムが適切に情報を扱うことを可能とするデータ構造
- プログラムの操作や使用法を記述した情報

## ソフトウェアの特徴
- 新しい環境や技術のニーズを満たすよう適応しなければならない．
- 新しいビジネス要求を実現するために強化されなければならない．
- より近代的なシステムやデータベースと相互運用するため拡張されなければならない．
- 進化し続ける環境で実行可能となるよう，再構築されなければならない．

# ソフトウェア工学とは
## ソフトウェア工学のゴール
進化論に基づく（ソフトウェアシステムが変化し続ける状況に対応する）方法論を考え出すことである．新しいソフトウェアが古いシステムから構築され，すべては互換性を持ち，他システムと相互運用しなければならない．

## ソフトウェア工学の定義
- ソフトウェアの開発，運用，メンテナンスに対するシステマティックで規律（discipline）である，定量化できるアプローチの適用，すなわちソフトウェアに対するエンジニアリングの適応である．
- ソフトウェアエンジニアリングツールは，プロセスや手法に全自動化もしくは半自動化の恩恵をもたらす．

## ソフトウェア工学の必要性
### ①大規模化と複雑さ
__ソフトウェアなしでは社会がまわらない．__
- ソフトウェアを効率よく開発し，メンテナンスする必要がある．
- 効率と品質の両立が求められる．
- 部品化，オブジェクト化が有効である．

### ②IT人材の不足
__（量的問題）ソフトウェアの需要に対してIT人材が追いついていない．__  
__（質的問題）ソフトウェアを効率的に開発・管理することのできる人材が少ない．__  
##### 次のような人材が求められている．
- 課題解決型人材＋価値創造型人材
- スペシャリスト
- プロジェクトマネジメント人材

### ③社会性と求められるミッション
- ライフライン・インフラストラクチャーとしてのソフトウェアが増加している．
- 不足の事態に対応した事業・サービスの継続が求められる．

### ④不確実性の増大
__ソフトウェア利用の変化・多様化が進行している．__  
- 検索型から交流型へ
- 意図しないソフトウェア活用  

__ニーズに対応したソフトウェアの開発が必要である．__

# ソフトウェアライフサイクル
## 1. 要件定義
__実現する機能・実現しない機能を明確にする．__
- 実現性評価としてFeasibility Studyがある．
- 機能の絞り込み，スケジュールの見直し，代替策の検討などにつなげる．  

__企業によっては要件定義項目をテンプレート化して漏れなく検討ができる工夫も行われている．__

## 2. 設計
__要件定義書から設計書を作成する．__  
__コーディングができるレベルの仕様書に落とし込む．__
- クラス，モジュール  

__WBS（Work Breakdown Structure）を活用する．__

## 3. 制作
__設計書に従ってシステムを構築する．__  
__内製（自社開発）__
- 一部機能をパッケージとして購入・外部委託する．

__調達（外部委託）__  
- 開発を外部に委託する．

__ソースコードを納品物に含めるか否か．__
- 含める場合→メンテナンスは自社で可能である．
- 含めない場合→メンテナンスは作業委託契約を締結する必要あり．

## 4. テストとデバッグ
__バグのないソフトウェアはない（と考えるべき）．__  
__あらかじめテストしバグを早期に発見・対処することが理想である．__    
__全てをテストすることは不可能である（工数に限界がある）．__    
__ソフトウェアのどの箇所をテストするか．__   

__どの程度テストするか．__  
- クラスや関数の中までデバッグするか．

## 5. 運用・保守
- 稼働後のデータをプロアクティブに活用するべき．
- ソフトウェア以外の要因も考慮する必要がある．
- 開発者はプロジェクトから離れている可能性がある．

# 開発プロセス
## ウォーターフォール型開発プロセス
- 進捗管理が容易，成果物が明確である．
- 後工程にしわ寄せが集中するというリスクがある．

## スパイラルモデル
- プログラム開発を小さなフェーズに分割する．
- フェーズごとにプロトタイプによるデモンストレーションを行う．
- プロトタイプ作成に想定外の作業量が発生するリスクがある．

## 反復型開発プロセス
- ソフトウェアを機能分割し，これを「反復」と呼ぶ単位で管理する．
- 部分的に完成させていくため顧客の要求を取り入れやすい．
- 部分的な納品が可能である．
- 分割のための作業や管理業務が増える．
- 全体像が見えづらい．
- 一括して稼働するシステムは分割しても意味がなくなってしまう．

## アジャイルプロセス
- agile（機敏な，俊敏な）が由来である．
- エンジニアの「寛容さ」を考慮している．
- 辺に対応して無駄を廃して最適な方法で動くソフトウェアの提供を優先している．
- ウォーターフォール型開発プロセスでは想定されていなかった「できるだけ決定を遅らせる」，「できるだけ早く提供する」を実現している．
- モチベーションを上げて学習効果を高めることで無駄をなくす．

# WBS（Work Breakdown Structure）
__プロジェクト目標を達成し，必要な要素成果物を生成するために，プロジェクトチームが実行する作業を，要素成果物を主体に階層的に要素分解したもの．__
- プロジェクトを細かな作業（Work）に分解（Breakdown）した構成図（Structure）である．
- 作業を細かく分解し，作業順に並べる．

## メリット
- スコープが明確になる（やらないことが明確になる）．
- 作業を洗い出す（やるべき作業が明確になる）．
- 全体管理と作業計画が明確化される．
- プロジェクト実施時はWBSに則り実行するだけでよい．

# UML
## UMLとは
- 万国共通の記法である．
- オブジェクト指向プログラミングに使われる．
- 文章によるドキュメントに加えて開発・設計を図式化（モデル化）する．

## UMLの種類
__論理ビュー__
- クラス図
- オブジェクト図
- 状態マシン図

__プロセスビュー__
- アクティビティ図

__開発ビュー__
- パッケージ図
- コンポーネント図

__物理ビュー__
- 配置図

__ユーズケースビュー__
- ユースケース図

# コーディング
__コードは書くよりも読まれることの方が多い__
__ソフトウェア開発にあたり読みやすいコードを書くことは必須である．__
- 他人が読みやすいコード
- 未来の自分が読みやすいコード
- ルールが必要

## コーディング規則の例（PEP8）
### 1行の長さ
- 79文字以内，docstringやコメントは72文字以内にする．
- 行を継続する場合は，折り返された要素を縦に揃える（Hanging indetation）．

### レイアウト
- 1レベルインデントするごとに，スペース（タブではなく）4つ使う．

### スペース
- 演算子の前後にスペ-スを1つずつ空ける．
- 優先度の異なる演算が混じる場合，交友鮮度の演算子の前後にスペースを入れる．
- 無駄なスペースを入れない．

### 改行
- 文を重ねない．
- 演算子の位置を揃える．

### import
- 標準ライブラリ，サードパーティに関連するもの，ローカルなアプリケーション・ライブラリに特有のものの順に書く．

### コメント
- 英語で書く．
- コードと矛盾するコメントは書かない．
- コードを変更した時にはコメントも変更する．
- コメントは大文字で始める（はじめの単語が小文字で始まる識別しでない限り）．
- コメントが2つ以上の文からなる場合，文の終わりのピリオドの後に2つスペースを入れる（最後の文を除く）．

### 命名規則
#### パッケージ
- 全て小文字の短い名前でかく．
- アンダースコアを使わない．

#### モジュール
- 全て小文字の短い名前でかく．
- アンダースコアで区切ってもよい．

#### クラス・例外
- 先頭だけ大文字にする．
- アンダースコアを使わない．

#### 関数・メソッド
- 小文字のみにする．
- 必要に応じて単語をアンダースコアで区切る．

#### 定数
- 大文字のみにする．
- 単語をアンダースコアで区切る．
- 通常，モジュールレベル（関数の外側）に書く．

#### 変数・引数
- 小文字のみにする．
- 必要に応じて単語をアンダースコアで区切る．

#### 1文字変数
- l（小文字のエル），O（大文字のオー），I（大文字のアイ）は決して使わない（フォントによって数字の1，0と見分けがつかないため）．

#### その他
- UTF-8以外のエンコーディングは可能な限り使わない．
- ASCⅡ以外の使用を極力避ける（日本語でも同様である）．
- PEP8のスタイルガイドに合わせることは重要だが，プロジェクトの中で一貫性を保つことはさらに重要である．

# git/github
## gitの特徴
- 分散管理型のバージョン管理システムである．
- 元々はオープンソースソフトウェア管理のためのソフトウェアであった．
- 変更履歴が残る．
- 変更した箇所に戻ることができる．
- 他人と共同編集できる．

## gitが持つ機能
### コミット
__ファイルの作成，変更，削除の記録を行う．__
- いつ・誰が・何を・どのようなを記録する．
- コミットにメッセージを残す（「どのような」を記載する）．  

__対象ファイルは1つでも複数でもよい．__  
__コミットの単位はユーザが自由に決定する．__

### レポジトリ
#### gitが管理するプロジェクトのフォルダである．
- ローカルレポジトリ･･･個々のプロジェクト実行環境
- リモートレポジトリ･･･共有の管理場所（Github/Gitlabなど）

### ブランチ
__作業を枝分かれさせることができる．__
- 共同作業・並行作業が可能である．

## githubの特徴
- リモートレポジトリのホスティングサービスの1つである．
- オープンソースソフトウェアの主要なポータルサイトである．

## gitのコマンド
__git config --global user.name yourname@example.com__
- ホスト（OS）全体のgitの設定を行う．  

__git symbolic-ref HEAD refs/heads/main__
- HEAD（ローカルレポジトリでの最新の状態）をmainと設定する．  

__git branch --set-upstream-to origin/main__
- リモートブランチ（origin/main）と紐付ける設定をおこなう．  
- originはリモートでのデフォルトのサーバーである．  

__git stash__
- 一時退避する．

__git diff origin -- index.html__
- originにあるindex.htmlとローカルのindex.htmlの比較を行う．

__git pull__
- originからプル（同期）する．

__git stash pop__
- 一時退避したものに変更を加える．

__git merge --abort__
- mainブランチをマージを試行する前の状態に復元する．

__git reset --hard__
- マージを開始する前の状態に戻す．

__git init__
- gitの初期化・設定を開始する．

__git status__
- ワークツリーのステータスを表示する．

__git config__
- 設定周りの確認・変更を行う．

__git log__
- ログを表示する（-- onlineでコミットメッセージの1行のみの一覧表示を行う）．

__git diff__
- ファイルの差分を表示する．

__git add__
- ステージングエリアに追加する．

__git commit__
- コミットを実行する．

__git commit --amend --no-edit__
- コミットを修正する．

__git reset__
- コミットをリセットする．

__git revert__
- 「コミットの変更を打ち消す」コミットを行う．

__git rm__
- ファイルとindex情報を削除する．

__git clone__
- レポジトリをコピーする．

__git pull__
- リモートレポジトリを同期する．

__git push__
- 変更をアップロードする．

__git request-pull__
- プルリクエスト（変更依頼）を行う．

__git remote__
- リモートレポジトリを設定する．

__git branch__
- ブランチを作成する．

__git checkout__
- ブランチを切り替える．

__git merge__
- ブランチを統合する．

# CI/CD
## Continuous Integration（CI）
- コード変更を共有レポジトリに頻繁に統合するプロセスである．
- 自動テストとビルドを定期的に実行し，バグの早期発見と修正を可能にする．
- CIの自動化により開発のスムーズな進行を促進する．

## Continuous Delivery（CD）
- コード変更をテスト環境や本番環境に自動的にデプロイするプロセスである．
- 自動デプロイメントを組み込み，手動操作によるデプロイの必要性を排除する．
- CDによりユーザーフィードバックを迅速に反映可能である．

## CI/CDパイプラインの基本的なステップ
__1. ソース__
- コード変更をトリガーにワークフローを起動する．

__2. ビルド__
- ソースコードをコンパイルする．

__3. テスト__
- 自動テストを実行する．

__4. デプロイ__
- テスト済みのコードを本番環境にデプロイする．

__5. 検証__
- デプロイされたアプリケーションの動作確認を行う．

__6. モニタリング__
- 本番環境で継続的に監視する．
